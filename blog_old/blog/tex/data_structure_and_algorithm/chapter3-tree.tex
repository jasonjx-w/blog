\documentclass{ctexart}
\usepackage{graphicx}
\usepackage{cite}

\begin{document}
\title{树(Tree)}
\author{ }
\maketitle


%\chapter{树(tree)}


%术语
\section{树（tree）}
\paragraph{基本概念}

\subparagraph{度(degree)}某个结点(node)的子树的个数为该\emph{结点的度}.其中最大值的为\emph{树的度}.
\subparagraph{分支结点(branch)与叶节点(leaf)}度不为零的结点,为\emph{分支结点}.度为零的结点为\emph{叶节点}.
\subparagraph{子结点(child)，父结点(parent)和兄弟结点(sibling)}
\subparagraph{层(level)和高度(depth)}根节点为第一层(或第0层),树中结点的最大层次为树的\emph{高度}.
\subparagraph{有序树和无序树}各结点子树按照一定的次序从左向右,且次序不可以随意改变,称为
\emph{有序树},否则为\emph{无序树}.
\subparagraph{森林(forest)}$m(m\geq 0)$棵树的集合



%树的各种公式性质.
\paragraph{树的性质}
\begin{enumerate}
  \item 树的结点总数=所有结点的度之和+1
  \item 度为$m$的树的第$i$层,至多有$m^{i-1}$个结点.\footnote{因为度为$m$,第2层结点至多为$m$,第3层至多为$m \times m$.}
  \item 高度为$h$的m叉树至多有$\frac{m^b-1}{m-1}$个结点.\footnote{根据上一条性质,高度为$h$的$m$叉树的结点个数最多为:$m^0+m^1+..m^{h-1}$.}
  \item 具有$n$个结点的$m$叉树最小高度为$ceil[\log_m{n(m-1)+1}]$.\footnote{ceil[n] 表示取大于n的最小整数.}
\end{enumerate}


\paragraph{树概念的表示方法}
\begin{enumerate}
  \item 树形表示法
  \item 文氏图表示法：使用大圆圈表示根，其中小圆圈表示子树。
  \item 凹入表示法：根对应一个长矩形，其子树用较短的矩形表示并在父结点之下；所有兄弟结点长度一致。
  \item 嵌套括号法
\end{enumerate}


%三种存储方式
\paragraph{存储方式}
\begin{enumerate}
  \item \textbf{广义表存储}：根结点为表头，表头指向长子结点，长子结点链接次子结点。如果某结点为分支结点，则该结点的值为指向另一个子链表的指针。即用一个嵌套链表表示树。
  \item \textbf{双亲存储结构}：在每个结点中，附一个指针域，指向父节点。(但找子节点需遍历整个序列)
  \item \textbf{孩子存储结构}：根据树的度，设计每个结点中的指针域的个数，指向子结点。
  \item \textbf{孩子兄弟存储结构}：每个结点附指针域指向\emph{长子}和自己同层的\emph{兄弟结点}。
\end{enumerate}


%二叉树的概念和性质.
\newpage
\section{二叉树（Binary Tree）}
二叉树是一种特殊的树，其结点为一个有限集合（该集合可以为空），每个结点最多有两个子结点，并且左右子结点有次序之分。

$m$叉树可以通过\emph{孩子兄弟存储法}转换成二叉树\cite{lichunbao}，且二叉树更为规范。

\textbf{满二叉树}是所有叶结点全部在最下层的二叉树，即树结构各个位置均被结点填满；\textbf{完全二叉树}是只有最下层不满的二叉树，即除最下层外，各层各位置均被结点填满。

二叉树可以可以分为\emph{顺序存储}和\emph{链式存储}方式。\emph{顺序存储}用连续的存储单元来存放二叉树的数据元，最好用于存储完全二叉树，对于单分支结点较多的二叉树空间利用率低。另外，二叉树的插入，删除等十分不便。\emph{链式存储}使用一个值域存放数据，两个指针域(左，右)指向左右子结点，有着链式存储方式的优点。


\subsection{二叉树性质}
\begin{enumerate}
  \item 非空二叉树上叶结点数$n_0$等于双分支结点数$n_2+1$，$n_0=n_2+1$。
  \item 如果树从第0层开始，非空二叉树上\textbf{第$i$层}上至多有$2^{i}，(i \geq 0)$个结点。（如果从第1层开始，$2^{i-1}，(i \geq 1)$个结点）
  \item 高度为$h$的二叉树\textbf{一共}至多有$2^{h+1}-1,(h \geq 0)$个结点。
 \end{enumerate}

\subparagraph{满二叉树}高度为$h$的\textbf{满二叉树}有$2^{h+1}-1,(h \geq 0)$个结点。
\subparagraph{完全二叉树}
\begin{enumerate}
  \item 具有$n$个结点的完全二叉树的高度为$log_2{(n+1)}-1$
  \item 对于完全二叉树，若其结点编号从0开始（各结点编号为$0...n-1$），
  则编号为$i(0\leq i\leq n-1)$的结点：
    \begin{enumerate}
      \item 若$i=0$,则$i$结点为根节点，没有父结点；若$i \geq 0$,则$i$结点的父结点编号为$ceil(\frac{i-1}{2})$
      \item 编号为$i$的结点，其左子结点为$2\times i+1(2\times i+1<n)$,右子结点为$2\times i+2(2\times i+2<n)$.
      \item 若$i$为偶数，则它是右结点（根结点除外，i != 0）；若$i$为奇数，则它是左结点。
      \item 编号为$i$的结点，其层次为$\log_2{(i+1)}$。
    \end{enumerate}
\end{enumerate}



\subsection{抽象数据类型接口（ADTI）}
对于二叉树，除构造和析构函数外，还需提供插入结点，删除结点，遍历，搜索，和显示函数。

每种函数根据具体细节可能提供多个函数。
\begin{verbatim}
    // 1.插入结点部分
    int InsertAsRoot(T x);
    // 在pointer的左子结点处，插入新结点
    int InsertAsLeftChild(BinaryTreeNode<T>* pointer, T x);
    // 在pointer的右子结点处，插入新结点
    int InsertAsRightChild(BinaryTreeNode<T>* pointer, T x);

    // 2.删除结点部分
    // 删除sub_tree的所有子树(不包括sub_tree结点）
    void RemoveSubTree(BinaryTreeNode<T>* sub_tree);
    void Clear(); // 清空树

    // 3.遍历部分
    // 4.搜索部分
    // 5.显示部分
    void Display();  // 用凹入法显示二叉树
\end{verbatim}

\subsection{数据类型的实现：顺序存储}


\subsection{数据类型的实现：链式存储}
\paragraph{结点的插入}
插入操作必须是：在\emph{当前结点的子结点}位置上，插入新结点。

链表在插入新结点时，只需new一个新结点，并将其按需要链接到原链表中即可。与链表不同的是，树的插入是需要指定具体位置，即指定位置的\emph{结点指针}。

如果插入操作使用的是在\emph{当前位置}插入新元素的话，则无法及时更新其父结点的指针域指针。将会有以下问题：

比如当需要在某结点插入新元素时（如果插入函数的参数为结点指针pointer和元素值x）使用如下代码的话：

\begin{verbatim}
    auto* node = new BinaryTreeNode<T>;
    node->_data = x;
    node->_left = NULL;
    node->_right = NULL;
    pointer = node; // 结点指向node
\end{verbatim}

如上述代码这样，用来指定插入位置的结点指针被更新后，但没有在父结点的指针域中更新相应的值\footnote{原来父结点中值为NULL}，将会导致断链，父结点不指向新的子结点。

如果指定插入位置的结点指针的话，就会有上述问题：指定的结点位置指针指向新创建的结点。

如此操作的话，必须有类似链表的操作：保持一个指针指向某结点的父结点。将新创建的结点，重新链接到父节点的指针域中。因此在某结点的子结点位置插入新结点较为简洁。


\paragraph{子树的删除}
如果想要保存某结点Node==NULL的标志，则需要在删除左右子树后，将当前结点对应的指针域置为NULL。由于这里采用的是\emph{二叉链表}的方案，没有指向父节点的指针。

所以删除操作应该是：删除输入结点的左右子树（并不删除输入结点），并且将对应的指针域置NULL。\emph{如若想要删除某结点，输入结点应该是其父结点。}

\textbf{使用递归调用时，应该尤其在意调用函数的执行顺序。}什么时候调用下一级函数，\textbf{逻辑判断会不会影响递归调用}，该函数返回后需要执行什么操作。

考虑到该子树删除函数并不删除输入结点，所以在调用时，具体删除操作应该在递归调用之后。即删除子树后，再删除当前结点。
\begin{verbatim}
    RemoveSubTree(sub_tree->_left); // 递归调用
    delete sub_tree->_left; // 删除操作
    sub_tree->_left = NULL;
\end{verbatim}
如若不然，则在递归调用后，直接执行后续代码，会漏掉当前结点。

\begin{verbatim}
auto* child = sub_tree->_left; //child为输入结点的子结点
if (child->_left == NULL
          && child->_right == NULL) { // 若child是叶节点
    delete child;            // 删除操作
    sub_tree->_left = NULL;
} else {
    RemoveSubTree(child);  // 递归调用
    // 如果child不是叶结点，在递归调用删掉其子树后，
    // 会直接执行后续代码，漏删child结点(该函数不删除输入结点)
}
\end{verbatim}

由此说明：分析递归调用除了要\textbf{分析递归调用过程}之外，还要\textbf{分析递归返回过程}。即应首先从上而下的分析调用过程；随后应从底层自下而上的分析逐级返回的过程。并且应\textbf{清晰的定义递归函数要实现的功能}，在自下而上和自上而下的分析中，作为基准。

如果递归函数定义不清晰，很容易造成代码冗余，甚至造成混乱。因为会很自然的像调用非递归函数那样，企图在调用之前为被调用函数做一些处理。但因为是递归调用，自己调用自己，这些处理完全可以在递归调用时交由下一层调用来完成。

\paragraph{父结点的查找}
因为没有使用指向父节点的指针，所以查找父节点会不可避免的涉及到递归（recurve）操作。在递归调用过程中，如果遇到所求结点，则可以将此结点返回（逐级返回）；或使用全局变量存储所求结点，函数逐级返回找到所求结点的标志。但考虑到代码的简洁性，应该优先选择直接返回所求结点的方法。

并且，因为是递归调用，所以递归函数应当输入当前结点指针，以保证递归调用可以逐级检查到树的各层结点。

查找当前结点N的父节点的思路，就是检查每一个结点的子结点，是否就是当前结点N。即如果某结点C 的子结点就是当前结点N，那该结点C 就是当前结点N的父结点。

每个结点的状态可以分为三种：1）为NULL---当该结点为叶结点时；2）为Node---已找到父结点；3）都不是---需要继续递归调用。

代码中必须\textbf{顺序}检查左结点，随后右结点。为了保证可以依次调用检查左结点和右结点的代码，检查为NULL部分不应该在此处进行，否则代码应该是\emph{先判断左结点是否为NULL，如果不是NULL，进而递归调用；再判断右结点是否为NULL，如果不是进而递归调用。}但是这样，不能实现左右结点的依次检查，同时返回结果。

\paragraph{遍历（Traversal）}
所有遍历均使用递归的思想实现。
\subparagraph{前（先）序遍历（pre-order）}是（递归地）先对当前结点进行操作，再访问左结点，再访问右结点。即先对当前结点进行操作，之后再访问别的结点，称之为“先序”。\emph{先序遍历大体顺序是：第一个结点是根结点，第二个结点是其左子结点，再左下角点，随后是右子结点。}

\subparagraph{中序遍历（in-order）}是先访问左结点，之后再对当前结点进行操作，最后访问右结点。即对当前结点额操作操作，在访问两个结点之间，称之为“中序”。\emph{中序遍历大体顺序是：第一个结点是最左下角点，第二个结点是其父结点，随后是次左下角点，最后是右子结点。}
\subparagraph{后序遍历（post-order）}是先访问左结点，再访问右结点，最后对当前结点进行操作。即访问左右结点之后，再对当前结点进行操作，称之为“后序”。\emph{后序遍历大体顺序是：第一个结点是最左下角点，第二个结点是次左下角点，整体看上去像是从左下角点开始的逆时针外包线。}

上述三种顺序只是对当前结点的操作的位置有区别，实际程序在访问一颗树时的顺序是一致的。其中先序变量是程序第一次访问到当前结点时就进行操作，而中序变量是第二次访问该结点时进行操作，而后序遍历是第三次访问该结点时进行操作。

\textbf{同时给定一棵树的前序序列和中序序列，可以唯一确定一颗树。}前序序列中的第一个元素肯定是树的根，用该元素可以将中序序列划分为左子树，当前结点，右子树，三部分。

如此，顺序取出前序序列中的元素，作为当前结点，可以不停地将中序序列进行划分，直至形成一棵树。


\paragraph{不用递归实现遍历}
上述过程使用递归实现，也可以使用栈和队列实现。用循环和栈代替递归，用栈记录访问回退路径。

\subparagraph{用栈实现先序遍历（pre-order）}其思路是，先对当前结点进行操作，再访问其左结点，同时将其右结点压栈；一直循环到叶节点，再依次对出栈的结点进行上述操作。最后，直至左子结点为空，栈也为空，整个循环结束。

\subparagraph{用队列实现层序遍历}其思路是，当访问某结点时，将其子结点依次入队。如果队列非空，则执行出队的元素，对出队的某元素进行操作时，依然要将其子结点入队，直至队空。这里对队列的使用与计算\emph{杨辉三角形}思路类似。

使用队列可以将待操作的数据入队，在执行某步操作时，将待执行操作入队。类似代办清单（list），根据队列顺序依次执行操作即可。

\subparagraph{用栈实现中序遍历（in-order）}中序遍历在访问某结点时，先将其压栈，再访问其左子结点，直至到叶结点。随后不断出栈，访问该结点和其右子结点。只将当前结点压栈，符合中序遍历，第二次访问才进行操作的特点。



\subsection{后序遍历应用举例：树结点计数和高度计数}
后序遍历的特点是：对当前结点进行操作之前，已经遍历过左右子树，即已经对左右子树进行过操作。

在树结点计数的例子中，使用后序遍历，在将本结点累加到总数变量之前，已经拿到了左右子树的结点总数，继续累加即可。对于高度计数也是类似思路。



\newpage
\section{线索二叉树（Thread Binary Tree）}
由于树的遍历比较浪费资源，因此可以使用称之为\emph{线索（thread）}的指针域，指向后继结点，简化遍历过程。

比如某树采用先序遍历排序，根据先序序列，树各结点增加一个指针域指向先序序列顺序中的后继结点，由此遍历一棵树可以像遍历链表一样。

使用线索的树，称之为\emph{线索树}。




\newpage
\section{通用树和森林}
\subsection{森林和二叉树的转换}

\subsection{森林和树的遍历}


\newpage
\section{堆}


%霍夫曼树的概念和性质.
\newpage
\section{Huffman树}

\paragraph{加权路径长度}

\paragraph{Huffman编码}

\paragraph{长子-兄弟存储-寻找p节点的父节点}
从某一节点开始寻找(通常是根节点).顺序是先检查子结点,后检查兄弟结点,用递归调用检查子结点,返回时继续检查兄弟结点.直至遇上终止条件:找到p或者为NULL.







\newpage
\begin{thebibliography}{1}
\bibitem{yanweimin} 严蔚敏. 数据结构（C语言版）. 北京: 清华大学出版社, 2007.
\bibitem{dengjunhui} 邓俊辉. 数据结构（C++语言版）(第三版). 北京: 清华大学出版社, 2013.
\bibitem{lichunbao} 李春葆. 数据结构考研指导. 北京: 清华大学出版社, 2002.
\bibitem{yinrenkun} 殷人昆. 数据结构：用面向对象方法与C++描述. 北京: 清华大学出版社,1999.
\end{thebibliography}




\end{document}
